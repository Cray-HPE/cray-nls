---
$schema: "https://json-schema.org/draft/2020-12/schema"
title: "Product Manifest for HPE CSM Install-Upgrade Framework (IUF)"
description: >
  A manifest that defines the behavior of the IUF when it performs operations
  against this product.
# This is the version of the schema itself
version: 0.1.0
type: object
required:
- schema_version
- name
# TODO: Generally would like this throughout all objects as it provides more
# guarantee of backwards compatibility of old manifests with newer schema.
additionalProperties: false
properties:

  schema_version:
    description: >
      The version of the IUF product manifest schema used by this manifest. The
      version of the schema should be a SemVer-like version number with three
      components, major.minor.patch.

      This version will be checked against the current schema version understood
      by the IUF.

      Compatibility is defined as follows. Let us refer to the schema version
      specified by the product manifest file as the "manifest version" and the
      current schema version used by the IUF as the "current version".


      - If the input version has an older major version than the current
        version, it is incompatible.

      - If the input version has an older minor version than the current
        version, it may be incompatible, but will be accepted with a warning.

      - If the input version has an older patch version than the current
        version, it is compatible.

      - If the input version is newer than the current version, it is
        incompatible because it could contain new fields not understood by the
        current version.

      - If the input version matches the current version, it is compatible.
    # TODO: Atif want to see this with a range, e.g. ^1.0.0 or ~1.0.0
    default: '1.0.0'
    type: string

  name:
    description: >
      The name of the product. This product name is the name under which the
      product will be uploaded to the product catalog.
    type: string
    # TODO: Do we want to define a regular expression for allowed product names
    # pattern: regex in ECMA-262 regular expression dialect goes here

  # TODO: Do we want a long name in a description too?
  description:
    description: >
      A longer name for the product. This is for humans to read and understand.
      E.g. slingshot-host-software could say what SHS stands for.
    type: string

  version:
    description: >
      The version of the product. The format of this version string must conform
      to the Semantic Versioning 2.0.0 Spec. The version numbers do not need to
      be assigned and incremented in accordance with the rules and requirements
      dictated by SemVer, however.

      # TODO: Consider whether we want to fall back on the `.version` file that some products
      # deliver in the release distribution tar file. E.g. Slurm provides one. We don't want
      # to make the build process more complicated. Or provide a path to the version file. In
      # this case, we could use a oneOf in the schema.

      # TODO: Need to look at SLE, CPE, and other products to see if they can fit into SemVer
      # Note that SemVer is pretty flexible (e.g. should be able to support SLE date strings).
      # Product like CPE already have to conform to use cray-import-config/cf-gitea-import
    type: string
    # This regex is the official one from the FAQ on semver.org
    pattern: '^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$'

  content:
    # TODO: Consider whether defaults can/should be specified at this level (in case content property is omitted)
    default:
      docker:
      - path: docker
        strip_leading_components: 0
    type: object
    description: >
      The content delivered by this product, including container images, RPMs,
      packages repositories, helm charts, loftsman manifests, VCS repositories,
      IMS images and recipes, and S3 artifacts.


      Note that if the layout of the content is not specified in this manifest,
      the IUF will assume a default layout as described in the properties here.

    properties:
      docker:
        description: >
          An array of directories containing docker images that should be
          uploaded to the Docker image registry in Nexus at install/upgrade
          time.

        default:
        - path: "docker"
        # TODO: do we want this as opposed to objects.
        # - "docker"

        type: array
        items:
          type: object
          required:
          - path
          properties:
            path:
              description: |
                The path, relative to the top level of the release distribution
                directory, containing the container images to be uploaded to the
                Docker image registry in Nexus.

                The directories contained within the directory specified here
                must contain container images. The container images will be
                uploaded to Nexus with names exactly matching the full path to
                the directory containing the image manifest.json file.

                For example, if this path contains the following file structure

                arti.hpc.amslabs.hpecorp.net/
                └── my-container:1.2.4
                    ├── 007c21b118030b56ce4c303c6ef668f6bdcf2e14f5e63f079b19e1d1883ac7a9
                    ├── ...
                    ├── manifest.json
                    └── version

                This container image would be uploaded to the Nexus registry as a
                arti.hpc.amslabs.hpecorp.net/my-container:1.2.4
              type: string

            # TODO: Do we need the ability to strip components from the path?
            # Maybe this needs a spike to see how product teams are storing their docker images.
            # E.g. SAT puts them all under cray/ prefix. COS mixes that approach with using
            # arti.hpc.../ prefix.
            # Maybe we don't need to worry about this. Make the product mirror the naming in the nexus
            # registry with their file structure.
            strip_leading_components:
              type: integer
              default: 0
              description: >
                How many leading components of the path should be stripped off when
                uploading the image to Nexus.

      helm:
        description: >
          An array of directories containing helm charts that should be
          uploaded to a Helm chart repository in Nexus at install/upgrade
          time.
        type: array
        default:
        - path: helm
          repository_name: charts
        # TODO: Consider simplifying this to just a list of strings like "docker" above
        # - "helm"
        items:
          type: object
          required:
          - path
          properties:
            path:
              description: >
                The path, relative to the top level of the release distribution
                directory, containing the helm charts to be uploaded to a Helm
                chart repository in Nexus.
              type: string

            # TODO: We can probably simplify here for now. Everybody is using "charts".
            # Putting charts in their own repository for each product is out of scope for IUF.
            # TODO: Investigate how loftsman knows which Helm repository to use from Nexus
            # Di says that loftsman needs local copies of the charts instead of going to Nexus.
            # We confirmed that loftsman uses local copies of charts (e.g. COS). File CASMTRIAGE for loftsman support of remote repos.
            repository_name:
              description: >
                The name of the repository to which the Helm charts should be
                uploaded in Nexus.
              type: string
              default: charts


      loftsman:
        description: >
          An array of Loftsman manifest files or directories containing Lofstman
          manifest files provided by the product.


          (TODO) What do we do with these files? Should they get uploaded
          somewhere on the system (e.g. a Nexus repository of some type or a
          bucket in S3)? Should they be processed with manifestgen (perhaps
          optionally)? Should some be flagged as manifests which should be
          deployed by the deploy\_product/deploy\_manifests stage while others
          can be skipped? David Gloe has a question about that.

          (TODO) Is there a need to specify dependencies here? Either within a
          single product's Loftsman manifests or between products?
        type: array
        default:
        - path: manifests
          deploy: true
          manifestgen: true
        items:
          type: object
          required:
          - path
          properties:
            path:
              description: >
                The path to a loftsman manifest file, relative to the top level
                of the release distribution directory.
              type: string
            use_manifestgen:
              description: >
                Whether manifestgen needs to be called against the manifest(s).
              type: boolean
              # TODO: Is it more common that products require this or do not require it?
              # Is it harmless if they do not require it?
              default: true
            deploy:
              description: >
                Whether this loftsman manifest should be deployed as part of the
                deploy_manifests stage of the IUF.
              type: boolean
              default: true

      rpms:
        description: TODO

      repositories:
        description: TODO

      vcs:
        description: TODO

      ims:
        description: TODO

      s3:
        description: TODO
