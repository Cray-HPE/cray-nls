---
$schema: "https://json-schema.org/draft/2020-12/schema"
title: "Product Manifest for HPE CSM Install-Upgrade Framework (IUF)"
description: >
  A manifest that defines the behavior of the IUF when it performs operations
  against this product.
# This is the version of the IUF manifest schema itself
version: 0.1.0
type: object
required:
- iuf_version
- name
# TODO: Generally would like this throughout all objects as it provides more
# guarantee of backwards compatibility of old manifests with newer schema.
#
# Using additionalProperties false helps ensure backwards compatibility of old
# IUF manifest files with newer schema versions because old manifest files will
# not be able to use additional properties which are then later added to the IUF
# manifest schema.
additionalProperties: false
properties:

  iuf_version:
    description: >
      The semantic version of the IUF with which this manifest file is expected
      to be compatible. Version constraints can be specified using ">", ">=",
      "==", "<", and "<=" comparison operators. Multiple comparison operators
      can be used to specify a range.


      Version constraints can also be specified with "~" (tilde) and "^" (caret)
      operators. A full version prefixed with "~" means that all versions with the
      same major and minor versions are compatible. That is, the patch version
      is allowed to differ. A full version prefixed with "^" means that all versions
      with the same major version are compatible. That is, the minor and patch
      versions are allowed to differ.


      It is recommended that products specify a caret range matching the
      current version of the IUF against which the manifest is developed. This
      will allow the manifest to continue working with new minor and patch
      versions of the IUF.
    type: string
    examples:
    - 1.0.0
    - ">= 1.0.0 < 2.0"
    - "< 2.0"
    - "~1.0.0"
    - "^1.0.0"

  name:
    description: >
      The abbreviated name of the product. This product name is the name under
      which the product will be uploaded to the product catalog.
    type: string
    examples:
    - cos
    - sat
    - analytics
    # TODO: Consider a regular expression for allowed product names
    # pattern: <regex in ECMA-262 regular expression dialect goes here>

  # TODO: Do we want a long name in a description too?
  description:
    description: >
      A description of the product.
    type: string

  version:
    description: >
      The version of the product. If not specified, the IUF will look for a
      file named ".version" in the top level of the release distribution
      directory.  If the version is not specified in the manifest, and there is
      no ".version" file, an attempt to install the product using the IUF will
      fail.

      It is recommended that products use a version string format which
      conforms to the Semantic Versioning 2.0.0 Spec. This does not require
      that the version numbers be assigned and incremented in accordance with
      the rules and requirements dictated by SemVer.

      If the product provides Ansible configuration content which is uploaded to a
      vcs repository (see the "vcs" property), then the version here must be a
      valid semantic version.
    type: string
    examples:
    - 2.4.76
    - 22.9.4
    - 1.3.0-rc.3
    - 2.5.8-20221004160837-9746d6e
    # If we can enforce that every product uses SemVer, then we can use the
    # following official regex from the FAQ on semver.org.
    # pattern: '^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$'


  # ===========================================================================
  # TODO: Another example of a way to do dependencies where each product can
  # declare what it provides vs. requires (similar to RPM).
  #
  # Deferred in Alice timeframe
  # ===========================================================================
  provides:
    type: array
    items:
      type: string
      description: TBD. Some sort of string describing what it provides.

  requires:
    type: array
    items:
      type: string
      description: TBD. Some sort of string describing what it requires.
  # ===========================================================================

  # ===========================================================================
  # TODO: One way of specifying dependencies between products would be to have
  # dependencies at the top level here.
  #
  # A lot of this is somewhat handled at the HPC CSM Software Recipe manifest
  # level because this is a set of software that has been validated together.
  # This doesn't handle one-off install dependency checking.
  dependencies:
    description: >
      The other products on which this product depends. This would be overall
      dependencies one product has on another, affecting all (?) stages/operations
      of the product.

      # TODO: Ask product teams about existing dependencies. Atif has not seen
      # any of these so far. Especially in upload_content. Dean cautions against
      # doing this at too high of a level because teams will get overly cautious
      # here and specify dependencies that aren't really needed.
    type: list
    items:
      type: object
      required:
      - product_name
      properties:
        product_name:
          description: Name of product on which this one depends.
          type: string
        product_version:
          description: Version of product on which this one depends.
          type: string
  # ===========================================================================

  content:
    # TODO: Consider whether defaults can/should be specified at this level (in case content property is omitted)
    default:
      docker:
      - path: docker
        strip_leading_components: 0
    type: object
    description: >
      The content delivered by this product, including container images, RPMs,
      packages repositories, helm charts, loftsman manifests, VCS repositories,
      IMS images and recipes, and S3 artifacts.


      Note that if the layout of the content is not specified in this manifest,
      the IUF will assume a default layout as described in the properties here.

    properties:
      docker:
        description: >
          An array of directories containing docker images that should be
          uploaded to the Docker image registry in Nexus at install/upgrade
          time.

        default:
        - path: "docker"
        # TODO: do we want this as opposed to objects.
        # - "docker"

        type: array
        items:
          type: object
          required:
          - path
          properties:
            path:
              description: |
                The path, relative to the top level of the release distribution
                directory, containing the container images to be uploaded to the
                Docker image registry in Nexus.

                The directories contained within the directory specified here
                must contain container images. The container images will be
                uploaded to Nexus with names exactly matching the full path to
                the directory containing the image manifest.json file.

                For example, if this path contains the following file structure

                arti.hpc.amslabs.hpecorp.net/
                └── my-container:1.2.4
                    ├── 007c21b118030b56ce4c303c6ef668f6bdcf2e14f5e63f079b19e1d1883ac7a9
                    ├── ...
                    ├── manifest.json
                    └── version

                This container image would be uploaded to the Nexus registry as a
                arti.hpc.amslabs.hpecorp.net/my-container:1.2.4
              type: string

            # TODO: Do we need the ability to strip components from the path?
            # Maybe this needs a spike to see how product teams are storing their docker images.
            # E.g. SAT puts them all under cray/ prefix. COS mixes that approach with using
            # arti.hpc.../ prefix.
            # Maybe we don't need to worry about this. Make the product mirror the naming in the nexus
            # registry with their file structure.
            strip_leading_components:
              type: integer
              default: 0
              description: >
                How many leading components of the path should be stripped off when
                uploading the image to Nexus.

      helm:
        description: >
          An array of directories containing helm charts that should be
          uploaded to a Helm chart repository in Nexus at install/upgrade
          time.
        type: array
        default:
        - path: helm
          repository_name: charts
        # TODO: Consider simplifying this to just a list of strings like "docker" above
        # - "helm"
        items:
          type: object
          required:
          - path
          properties:
            path:
              description: >
                The path, relative to the top level of the release distribution
                directory, containing the helm charts to be uploaded to a Helm
                chart repository in Nexus.
              type: string

            # TODO: We can probably simplify here for now. Everybody is using "charts".
            # Putting charts in their own repository for each product is out of scope for IUF.
            # TODO: Investigate how loftsman knows which Helm repository to use from Nexus
            # Di says that loftsman needs local copies of the charts instead of going to Nexus.
            # We confirmed that loftsman uses local copies of charts (e.g. COS). File CASMTRIAGE for loftsman support of remote repos.
            #
            # Rob found that loftsman command can use remote chart repos.
            # Unclear how this works. `--charts-repo` exists, but it is
            # deprecated in favor of `spec.sources.charts` in the manifests.
            repository_name:
              description: >
                The name of the repository to which the Helm charts should be
                uploaded in Nexus.
              type: string
              default: charts


      loftsman:
        description: >
          An array of Loftsman manifest files or directories containing Lofstman
          manifest files provided by the product.


          # TODO: Discuss with Atif where these manifests should be stored.
          # Also decide whether we store pre- or post-manifestgen versions.
          # This ties into the discussion about where we store hooks and any
          # artifacts needed for any future product install/upgrade/uninstall
          # operations.
          # Decision: they will be stored in S3 (pre- and post-manifestgen
          # versions)

          # TODO: Is there a need to specify dependencies here? Either within a
          # single product's Loftsman manifests or between products?
          # Discuss with Atif how dependencies are declared.
        type: array
        default:
        - path: manifests
          deploy: true
          manifestgen: true

          # TODO: Example of dependencies
          # dependencies:
          # - product: cos
          #   manifest_path: manifests
        items:
          type: object
          required:
          - path
          properties:
            path:
              description: >
                The path to a loftsman manifest file or directory, relative to the top level
                of the release distribution directory.
              type: string

            # TODO: Consider whether dependencies between loftsman manifests are needed here
            # Jason suggests that perhaps they belong in a separate section.
            #
            # Decision: let's not do this for Alice. We can ask product teams
            # about whether this is required.
            #
            # Example schema below
            dependencies:
              type: array
              items:
                type: object
                properties:
                  product:
                    type: string
                    description: name of product
                  manifest_name:
                    type: string
                    description: name of manifest provided by product
            # End of example

            use_manifestgen:
              description: >
                Whether manifestgen needs to be called against the manifest(s).

                manifestgen takes the customizations.yaml file and applies the customizations
                to the Loftsman manifest file. Customizations to the manifest themselves or to
                to the values that are passed through to the helm charts.
              type: boolean
              # TODO: Is it more common that products require this or do not require it?
              # Is it harmless if they do not require it? Should be harmless.
              #
              # Atif want to move away from specifying all config values in
              # customizations.yaml and move towards having these be specified
              # by the admin either in a file or in a wizard guiding them
              # through answering required questions as part of starting an IUF
              # session. We will keep this unchanged for Alice to minimize
              # impact to product teams and improve in the future.
              default: true
            deploy:
              description: >
                Whether this loftsman manifest should be deployed as part of the
                deploy_manifests stage of the IUF.

                # TODO: Reach out to David Gloe to ask for specifics on the WLM use case.
                # Why would we ever not want to deploy manifests during the deploy_manifests stage?
                # Atif suggests asking this question at the next meeting with
                # product teams. Atif hasn't seen any examples where this would
                # be required. Assume they all need to be deployed.
              type: boolean
              default: true

      blobstores_definition:
        description: >
          The path to a YAML file that defines the blobstores that should be
          created for this product. The YAML file should consist of a series
          documents, each of which defines a blobstore.

          The schema of each document is unchanged from the Papaya recipe
          release.
        type: string
        # TODO: Do any products define more than one blobstore?
        # It is possible to do this with a single nexus-blobstores.yaml file
        # by specifying multiple documents. Check if any products define multiple
        # blobstores in multiple files (possible SLE)
        default: nexus-blobstores.yaml

      repositories_definition:
        description: >
          The path to a YAML file that defines the Nexus repositories that
          should be create for this product. The YAML file should consist of a
          series of documents, each of which defines a Nexus repository.

          The schema of each document is unchanged from the Papaya recipe
          release.

          # TODO: Define behavior when repositories defined here already exist in Nexus.
          # Investigate why Slurm had to delete the old repos. Was it a way to ensure
          # the type is modified.
          #
          # Atif suggests that we must always back up old content if we would
          # overwrite it. 
          #
          # This needs to be discussed further as part of the IUF spec.
        type: string
        default: nexus-repositories.yaml

      rpms:
        description: >
          An array of directories containing RPMs that should be uploaded to the
          repositories defined by the "repositories_definition" property.
        type: array
        items:
          type: object
          required:
          - path
          - repository_name
          properties:
            path:
              description: >
                The path to a directory containing RPMs to upload to a package
                repository in Nexus, relative to the top level of the release
                distribution directory.
              type: string
            repository_name:
              description: >
                The name of the repository to which these RPMs should be uploaded.

                # TODO: Should we support product name and version substitutions
                # in this file at product install time? Currently, many products
                # do this sort of variable substitution at packaging time in
                # `release.sh` by templating their nexus-blobstores.yaml,
                # nexus-repositories.yaml, and their install.sh files using sed.
                # It would probably be simplest for Alice to just allow products
                # to keep managing those substitutions themselves.
                #
                # Decision: For Alice, we won't worry about this. Post-Alice, we
                # could offer release-generation libraries to simplify across
                # products.

      # =======================================================================
      # An alternative way to define Nexus repos under a repositories property
      # instead of defining them in a separate file referenced by the value of
      # the "repositories_definition" property.
      # =======================================================================
      repositories:
        description: >
          An array of package repositories.
        type: array
        items:
          type: object
          required: name
          properties:
            name:
              description: The name of the repo to create
              type: string
            # More properties defining the repo would go here.
      # =======================================================================

      # =======================================================================
      # An alternative way to define Nexus blob stores under a blobstores
      # property instead of defining them in a separate file referenced by the
      # value of the "blobstores_definition" property.
      # =======================================================================
      blobstores:
        description: >
          An array of blobstores that should be created in Nexus for this
          product.
        type: array
        items:
          type: object
          required:
          - name
          properties:
            name:
              description: The name of the blobstore to create
              type: string
            # More properties defining the blobstore would go here.
      # =======================================================================

      vcs:
        # TODO: Ask product teams if any product provides more than one VCS
        # repo.
        default: {}
        description: >
          Information about the VCS repository to be created for this product.
        type: object
        required:
        - path
        properties:
          path:
            description: >
              The path, relative to the top level of the product release
              distribution, to the directory containing the content to upload to
              a repository in VCS.
            type: string
          import_branch:
            description: >
              The branch name to which the content in the given path should be
              uploaded in VCS. If this is omitted, the default behavior is to upload
              to a path of the form cray/${PRODUCT_NAME}/${PRODUCT_VERSION} where
              PRODUCT_NAME and PRODUCT_VERSION are the name and version of the product,
              respectively. It is recommended not to change this value unless it is
              required to do so.
            type: string
          # The following property is one we want to allow the admin to
          # override. For Alice, let's not add this property. Let's just worry
          # about the content upload.
          site_branch:
            type: string
            description: >
              The branch name to use as the branch for site customizations.
              cpe-integration-22.09

      ims:
        description: >
          Information about the IMS images and/or recipes to be uploaded into
          IMS for this product.
        type: object
        properties:
          recipes:
            type: array
            items:
              type: object
              required:
              - path
              properties:
                path:
                  description: >
                    The path, relative to the top level of the product release
                    distribution, to the recipe as a gzipped tar file.

                    # TODO: Still trying to understand the structure here and
                    # how products will be able to build and package recipes.
                  type: string
                name:
                  description: >
                    Name of the recipe. Or we could default to the name of the tar file.
                  type: string
          images:
            type: array
            items:
              type: object
              required:
              - path
              properties:
                path:
                  description: >
                    The path, relative to the top level of the product release
                    distribution, to the directory containing the image artifacts.

                    # TODO: Still trying to understand the structure here and
                    # how products will be able to build and package images.
                  type: string
                name:
                  description: >
                    The name of the image to create.
                  type: string

      s3:
        description: TODO
